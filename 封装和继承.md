## 封装和继承

### 1.封装和继承

​	i 封装

​	为了隐藏细节

​	ii 继承

​	为了复用代码

​	iii 多态

​	灵活

####1.1原型链(对象与对象之间的关系)

```javascript 
var obj1 = {name:'1'};
window.Object.prototype === obj.__proto__; //true
```

![原型链](/home/storm/Documents/Mynote/原型链.png)

上面的原型链图形象的表示了他们之间的关系，说白了就是大家都共用同一个 “ 仓库” , 所有对象都共用 **Object**的原型，他们各自又有自己的 “ 仓库” 

` arr1.__proto__ === window.Array.prototype` 自己的 Array 仓库，里面有 join ,splice 等方法

`arr1.__proto__.__proto__ === window.Object.prototype`  Object的仓库，里面有 toString , valueOf 等方法

**Object 是所有对象的最底层的原型。**

#### 1.2this(对象与函数之间的关系)

函数： 可执行代码组成的一种对象

所有使用 `function`声明的函数都只有两个参数 this 和 arguments,

**一定要记住**

>**1.参数的值只有传参的时候才能确定**
>
>**2.this 是call()的第一个参数 **
>
>**=> this 的值只有在传参的时候才能确定**

```javascript
var obj = {
	name:'mayun',
    child:{
      name:'sicong',
      sayName:function(){console.log(this.name)}
    }
}

obj.child.sayName() //sicong this === obj.child  就是函数的 点 前面的所有
obj.child.sayName.call(obj) // mayun 因为 this === obj  obj.name === 'mayun'
//因此我们也可以看出 function(){} 跟这个 sayName 一点关系都没有， sayName 只是存了 function(){} 的地址而已
//更直观点
obj.child.sayName.call({name:'wtf'}) //wtf	

```



来几个题试试

```javascript
	function f(){ console.log(this) } 
	function f(){ console.log(this) } f()
	function f(){ ‘use strict’ console.log(this) } f()
	var obj = {sayThis:f} ; obj.sayThis()
	var obj = {sayThis:f} ; obj.sayThis.call()
	button.onclick = function(){console.log(this)}
	$('#test').on('click',function(){console.log(this)})
	$('#ul1').on('click','li',function(){console.log(this)})
	varvm = new Vue({data:function(){console.log(this)}})
```

答案

```javascript
1.不确定，因为没有传参啊	
2.window
3.undefined(use strict)
4.obj // . 前面的
5.window/undefined
6.button //浏览器保证的，只要点击了，this === button 
7.$('#test') //JQ文档写的 this指向了当前正在执行事件的元素
8.li //JQ文档 this 代表了与 selector 相匹配的元素
9.new 出来的对象 vm //文档说的,因为它call了new 出来的东西
```

# 那么这么蛋疼的this为什么还要用它，我们要用箭头函数！！

箭头函数自己没有 `this`和`arguments`

它的 this  是外面的 this 

```javascript
var f = ()=>{console.log(this)} f() //window 
var obj = { sayThis : ()=>{console.log(this)}} ; obj.sayThis 
// window ( 如果是function 那就是obj了) 
//因为obj的this是window，所以里面的也是window, ()=>{} 不接收this，也不修改this,外面是什么，它就是什么
```

#### 1.3 bind是什么

先看下MDN的定义

> `bind()`方法创建一个新的函数, 当被调用时，将其`this`关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。

做几个实验

```javascript //
function fn1(){ console.log(this) } //this是啥？不知道
fn1()// 哦，this 是 window
fn1.call(1) // this又是 Number(1) 了
//我想写一个直接就知道this是什么的函数
function fn2(){ fn1.call(1) } //this 肯定是 Number(1) ，我都钦定了,但是这么写有点啰嗦，JS帮我整个方法
var fn3 = fn1.bind(1) ; fn3()  // Number(1)
```

**上面我们说到了，this 其实只是函数的第一个参数而已，第二个参数是arguments，我能不能也钦定一下子？**

```javascript
function fn1(){ console.log(this) ;console.log(arguments) } 
fn1() // window []
function fn2(){ fn1.call(1,'a','b','c') } 
fn2()// Number(1) ['a','b','c']
//那这样的话，bind是不是也能指定arguments呢？
var fn3 = fn1.bind(1,'a','b','c');
fn3()// Number(1) ['a','b','c']
```

**所以说`bind（）`就是返回了一个函数，这个函数 call 原来的函数，而call的值你可以自己指定**

####1.4 new 是什么

##### 1.4.1 为什么要有 new ，我们的需求

​	我们想要 批量创建对象

